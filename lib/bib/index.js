const constants = require('../constants');
const fs = require('fs');
const os = require('os');
const { join, resolve } = require('path');
const log = require('log-symbols');
const Promise = require('bluebird');
const resolvers = require('./resolvers');
const utils = require('../utils');

/**
 * Add publication to bibliography.
 * @param {object} args - Command arguments
 * @returns {Promise}
 */
function add(args) {
    const resolver = resolvers.getResolver(args.query);
    return resolver
        .getCitation(args.query)
        .then(function(citation) {
            const bibFilePath = join(args.path, constants.DEFAULT_BIBLIOGRAPHY_FILENAME);
            return utils
                .ensureFile(bibFilePath)
                .then(utils.readFile)
                .then(function (bib) {
                    // TODO add new citation only if it doesn't already exist
                    // TODO check for same key but different citation
                    // TODO consider adding citations to file named after the source (ex. arxiv.bib)
                    // modify citation as required
                    bib += '\n\n' + citation;
                    return utils.writeFile(bibFilePath, bib);
                });
        })
        .catch(function(err) {
            console.log(error);
        });
}

/**
 * Parse console command.
 * @param {object} yargs - Console argument parser
 */
function command (yargs) {
    yargs
        .command('add <query>', 'Add publication', function(y) {
          y.option('path', {
                coerce: function (p) {
                    let i = p.indexOf('~');
                    return i > -1 ? p.replace('~', os.homedir()) : p;
                },
                default: process.cwd(), // TODO find project root
                describe: 'project directory path',
                type: 'string',
            });
        }, add)
        // TODO ensure that --path option with ~ is expanded
        .command('get [keys...]', 'Download publications', utils.noop, get)
        .command('export <key> <format>', 'Export citation', utils.noop, exportToFile)
        .command('init [path]', 'Create a new bibliography file', utils.noop, init)
        .command('remove <key>', 'Remove publication', utils.noop, remove)
        .command('search [query...]', 'Search', utils.noop, search)
    ;
}

/**
 * Export bibliography to new file.
 * @param {object} args - Command arguments
 * @returns {Promise}
 */
function exportToFile(args) {
    throw new Error('not implemented');
}

/**
 * Download publications.
 * @param {object} args - Command arguments
 * @returns {Promise}
 */
function get(args) {
    throw new Error('not implemented');
}

/**
 * Create a new bibliography.
 * @param {object} args - Command arguments
 * @returns {Promise}
 */
function init(args) {
    const f = join(args.path, constants.DEFAULT_BIBLIOGRAPHY_FILENAME);
    return new Promise(function(resolve, reject) {
        const data = '% bibtex bibliography generated by doc';
        fs.writeFile(f, data, 'utf8', function(err) {
            if (err) {
                reject(err);
            } else {
                resolve();
            }
        });
    });
}

/**
 * Remove publication.
 * @param {object} args - Command arguments
 * @returns {Promise}
 */
function remove(args) {
    throw new Error('not implemented');
}

/**
 * Search bibliography.
 * @param {object} args - Command arguments
 * @returns {Promise}
 */
function search(args) {
    throw new Error('not implemented');
}

function writeBib() {}

module.exports = {
    add,
    command,
    exportToFile,
    remove,
    search
};
